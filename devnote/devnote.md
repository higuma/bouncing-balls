# 開発メモ

(2014-09-08..12)

俺はCanvasだってできるんだぞというのを見せびらかしたい(本当にいやな性格だ...)。そこでひとつ作っておく。

> というよりビジネスアプリ関係の勉強ばかりで疲れてきた。たまにはこうやって遊んで息抜きしたい。

大体のイメージは次の通り。

* ボールの運動と衝突のアニメーション
* 基本機能ができたら色々なパラメータ調節をつける
    * 箱のサイズ
    * 球の大きさ
    * 速度(velocity)
    * 重力(gravity)
    * 摩擦抵抗(friction)
    * etc.

アニメーションの基本操作はcanvasしか使わないので外部ライブラリを使うことはほぼないが、パラメータ調整用コントロールは外部ライブラリを検討する。

* jQuery UIが第一候補
    * slider/spinner/radio buttonなど必要なものは揃っている
    * でもBootstrapと比べると何か作りが雑(というのが自分の個人的感想)
* Bootstrapもありうる
    * sliderはないがprogress barを代わりに使える
        * ただしこれを動かすアクションはない(でもこういう自作なら得意...)
    * やはり全体的な完成度が高い
    * やっぱりこっちかな...せっかく勉強したんだし
        * <https://github.com/higuma/bootstrap-3-note>

どっちにしろjQueryは使う。これ以外に外部ライブラリを使うことがないのであれば今回はすべてCDNで対応できる(bowerの登場機会はない)。

それでは組立を開始する。まずpackage.jsonとgulpfileの開発環境を整える。

* CSSはbodyだけ(フォント設定をBootstrapからもらってくる)
* JavaScriptは四角形を表示するだけ
* コントローラ関係はTODOと表示しておく

今回は開発過程もすべてgitに残す。

> いつもはできるかどうか分からない状態から始め、調べながら仕上げていくことが多いので開発初期段階ではgitは使わない。今回は最初から何をするか明確なので全部記録する(最初からできることは分かっている)。

------------------------------------------------------------------------

それではコーディング開始。以前読んだ本を参考(種本)にする(Chapter 7)。

* "Supercharged JavaScript Graphics" by Raffaele Cecco (2011)

最初はcanvas上にランダムな大きさの円を重ならないように配置する。ただし複雑なアルゴリズムは用いず、オーバーラップだけ判定して重なる場合は再試行する。

* 1000回試行
* 失敗時は例外発生としておく(仮仕様)

------------------------------------------------------------------------

次は球にグラデーションをつけてかっこ良くする。

* RGBのランダムな色を生成
    * 中心色は輝度0.5以上とする
    * 境界色は中心色から輝度を40%削減したもの
* グラデーションを生成
    * createRadialGradientを使う
    * 開始境界は球の外殻
    * 終点(グラデーション中心)は球の中心から1/4だけ左上の地点

(補足) 次はRGBのCSS表現`#rrggbb`を得るためのパターン。JavaScriptにはprintfのように先頭に0を埋める機能がないため、このようにsliceと組み合わせて生成する。

``` coffeescript
    innerCol = 0x003f6c   # (例)このような場合に先頭の00を確保するのが次コード
    innerRgb = innerCol.toString 16
    innerColor = '#000000'.slice(0, 7 - innerRgb.length) + innerRgb
```

------------------------------------------------------------------------

次は球を動かす。ただしまだ衝突はさせない。

* 球の初速はランダムに割り当てる
* 球同士の衝突判定はしない(オーバーラップしたら素通りする)
* 周囲の壁面は完全反射とする(これが一番簡単)
* 30 frame/sec でアニメーション

> ボールの数が25個だとCPU負荷がめちゃ高い(後で調整する)。

------------------------------------------------------------------------

次は球を衝突させる。

* 完全弾性衝突モデル(質量パラメータあり)
* 反射の数式は種本から頂戴した
    * 物理は得意なので自作可能
        * たぶんもっと厳密なのを作れる
        * しかし本気で作ると2-3日は掛かりそう
    * でもせっかく動くのがあるのだから利用する
        * おそらく2-3日の時間節約になる
        * 実はコードを読むとどうも厳密ではなさそう
        * しかし実際に動かしてみて特に不自然な点は見当たらない
        * 人間の感覚を騙すことには十分成功していると判断して採用する
    * ただしその後自分で大幅にreduceしたため原型は全くとどめていない
* 球の質量は半径に比例させる
    * 厳密に数学を適用すれば球なので3乗に比例させるべき
    * だが実際にやってみると当然小さな球が高速で飛び回ることになる
    * それっぽく見える程度でいいのでかえって単純比例の方が自然に見える

> ここでちょっと面白いことに気付いた。ChromeよりFirefoxの方がCPU負荷が少ない。普通なら完全に逆なのでこれはCanvas特有の現象だろう。

------------------------------------------------------------------------

次は重力を追加する。最初は設定は固定にする。

------------------------------------------------------------------------

次は(空気)抵抗を追加。次のシンプルな物理モデルを採用する。

* 抵抗力(加速度)は速度に比例して減衰する

しかしこれはまだ不完全。最後は地面を細かくバウンドする状態になり、いつまで経っても停止しない。

------------------------------------------------------------------------

最後は弾性係数を設定する。

> ここまでやれば物理モデリングと言っても差し支えないと思う。

* 衝突の対象は「球 vs 境界」と「球 vs 球」の2通りある(本来は別の値)
* しかしパラメータを増やしすぎても無用に複雑になるだけ
* 最低限のパラメータで豊かなバリエーションを表現できるのがベスト
    * よって一つに統一し
    * 2つの弾性係数の間に比例係数(定数)を設定する
    * 単に同じでもいい(最初はそうする)

これだけだとやはり最後は地面を細かくバウンドする。原因は重力で、常に一定の加速度を下向きに受けているため永久にバウンドが止まらない。

------------------------------------------------------------------------

最後は球がちゃんと停止するようにしたい。実際の世界では時間の差分は無限小なので弾性係数が1より小さければ必ず停止してくれるのだが、シミュレーションだと有限時間の間に重力分だけ加速してしまい永久に止まらない。

> さらに球の上に球が乗ってしまうと上の球が下の球を押しつぶす形になり、下の球が地面にめり込んだり突然ジャンプするなど現実ではありえない振る舞いを示す。

原因は分かっているので地面との反射に関して物理モデルを修正する。

* おかしくなるのは球が地面に接近して次の加速で衝突する場合
    * タイムスライス分全部重力加速してから衝突処理させている部分が間違い
    * 正しくは衝突する瞬間までの分だけ加速する

これで球は永久にはバウンドせずいつかは必ず停止するようになる。ただし球の密度が高い場合は球の上に別の球が乗ってしまいやはり上記の問題を生じる。これは簡単には直らないので後で考える。

またまれに大きな球が2つ重なってバウンドするようなケースで極端な加速が生じて画面がぐちゃぐちゃになる現象を把握している(ただしこれもいつかは減衰して収束する)。

> これは球同士の反射モデリング(拝借したコード)に問題があることを示唆しているが、こもともと重力を想定した実装ではないため仕方ない。文句を言うのは筋違いなのでこれも後で見直す。

------------------------------------------------------------------------

物理モデルにはまだ問題はあるが、ここでコントローラを付ける(その方が後々デバッグも楽)。まずどういうコントローラが必要か確認する。

* canvasの幅(px)
* canvasの高さ(px)
* 球の個数
* 球の大きさ(min/max)
* 球の初速(min/max)
* 重力
* 弾性係数
* 空気抵抗
* 開始・停止等のボタン

最初はモック画面をBootstrapで作って大体の感じを確認したが、Bootstrapにはsliderがないので最終的にはやはりjQuery UIを採用した。CDNはgoogleを利用する。

<https://developers.google.com/speed/libraries/devguide#jquery-ui>

それでは画面だけまず全部作ってしまう。

> ここの検討にかなり時間を要した。最初はfloatを使って段組で書こうと思ったがやはり細かい調整が難しい。結局tableを使った(面倒だが絶対に失敗しない)。

------------------------------------------------------------------------

画面が決まれば後は早い。コントローラアクションを一気に書き上げた。

> 約6時間で終了。コード量はかなり多いが一本道なので始めた後は早かった。

------------------------------------------------------------------------

その後で例外発生時(ボール密度が高すぎて配置できない場合)のcatch処理を加えた。その他空気抵抗などいくつかパラメータ範囲を調整した。これで基本部分は完成。後はまとめ方を検討する。

球同士の衝突処理には種本から拝借したコードを使っているが、これは質量の異なる球体の完全弾性衝突を処理するためのもので重力の関与は全く考慮していない。しかし今回シミュレーションパラメータとして次の3つを追加した。

* 重力
* 反射(弾性)係数
* 空気抵抗

弾性係数と空気抵抗に関しては問題ない。どちらも減速方向にだけ作用するものなので、いつかは球が停止して収束する。しかし重力はそうではないく、常に一定の加速度が加えられるため有限時間ステップのシミュレーションでは速度が0に収束しない。

また今回は厳密な剛体モデルではなく、微小時間運動した後で球が別の球や境界とオーバーラップした時に反射処理を行っている。そのため次のようなケースで問題を生じる。

球の密度が高くなると一回の微小運動の後で複数の球とオーバーラップするケースが発生する。片方とのオーバーラップを解決した後で別のオーバーラップ解決処理を行うと、最初の側とまたオーバーラップしてしまうことがある。

さらに密度が上がったり大きな重力が加わると、オーバーラップはいつまでも解決せず球が別の球や地面にめり込んだままの状態になる。

重力があり弾性係数が低い状態で、接地して球の上に別の球が乗り上げてしまった場合を考えると分かりやすい。上の球は最後は下の球の上で停止するが、下の球に上の球の重力がかかり続けるため、下の球は地面にめり込んでしまう。

これはモデルを改良し、座標更新前にすでに接地している場合は重力を加えないようにすれば改善できる。これで球が2つ重なった時に球が地面にめり込むことは少なくなる。しかしなくなることはない(剛体モデルを使ってないので当然)。

また少し前に非弾性衝突の場合は最後は地面をバウンドしないように地面衝突時の処理を修正した。しかしこれには副作用があり、完全弾性衝突している時でも僅かな減衰が生じ、最後には静止してしまう。

結局のところ実際の運動を微小時間差分で近似したシミュレーションなので、すべての条件でうまくいく方がおかしい。そこで今回は「モデリングが成立するかどうか条件を自分で設定できる」シミュレータというコンセプトで公開する。

今まで地面との反射で特殊な補正を2つ行っているが、ここで採用可否を判定する。

* 「すでに接地しているときは重力を加えない」は採用(副作用もない)
* 「非弾性衝突時に地面で止める」は非採用(副作用がある)

また場合によってはパラメータが発散する可能性もあり、実際に例外が発生するのを数回確認している。そこでシミュレーション実行中は例外をcatchし、もし発生したらalertを表示してinterval処理を止めるコードを追加する。

------------------------------------------------------------------------

最後にTODO項目のまとめ(でも多分やらないだろうな...)。

今は球を3D風グラデーションでrenderしているが、これはかなりのCPU消費になるため逆に簡略化するオプションを検討する。

> しかし30Hzのインターバル処理なので重くはなっても動作障害の可能性は少ない(でもIEだとやばいかも...)。Canvasが使えるモダンブラウザがこの程度の処理でおかしくなる方が悪いと勝手に(?)判断する。

また現在フレームレートは30Hzに固定しているが、これもパラメータ化を検討する(例えば5-100など)。

> しかしシミュレーションの成立条件はフレームレートと球速の相対関係で決まる。球速の側を設定可能にしているので本質的な追加とは言えない。

最後にドキュメントを整備して終了。今ひとつ楽しめなかった...


# 開発メモ

(2014-09-08..)

俺はCanvasだってできるんだぞというのを見せびらかしたい(本当にいやな性格だ...)。そこでひとつ作っておく。大体のイメージは次の通り。

* ボールの運動と衝突のアニメーション
* 基本機能ができたら色々なパラメータ調節をつける
    * 箱のサイズ
    * 球の大きさ
    * 速度(velocity)
    * 重力(gravity)
    * 摩擦抵抗(friction)
    * etc.

アニメーションの基本操作はcanvasしか使わないので外部ライブラリを使うことはほぼないが、パラメータ調整用コントロールは外部ライブラリを検討する。

* jQuery UIが第一候補
    * slider/spinner/radio buttonなど必要なものは揃っている
    * でもBootstrapと比べると何か作りが雑(というのが自分の個人的感想)
* Bootstrapもありうる
    * sliderはないがprogress barを代わりに使える
        * ただしこれを動かすアクションはない(でもこういう自作なら得意...)
    * やはり全体的な完成度が高い
    * やっぱりこっちかな...せっかく勉強したんだし
        * <https://github.com/higuma/bootstrap-3-note>

どっちにしろjQueryは使う。これ以外に外部ライブラリを使うことがないのであれば今回はすべてCDNで対応できる(bowerの登場機会はない)。

それでは組立を開始する。まずpackage.jsonとgulpfileの開発環境を整える。

* CSSはbodyだけ(フォント設定をBootstrapからもらってくる)
* JavaScriptは四角形を表示するだけ
* コントローラ関係はTODOと表示しておく

今回は開発過程もすべてgitに残す。

> いつもはできるかどうか分からない状態から始め、調べながら仕上げていくことが多いので開発初期段階ではgitは使わない。今回は最初から何をするか明確なので全部記録する(最初からできることは分かっている)。

------------------------------------------------------------------------

それではコーディング開始。以前読んだ本を参考(種本)にする(Chapter 7)。

* "Supercharged JavaScript Graphics" by Raffaele Cecco (2011)

最初はcanvas上にランダムな大きさの円を重ならないように配置する。ただし複雑なアルゴリズムは用いず、オーバーラップだけ判定して重なる場合は再試行する。

* 1000回試行
* 失敗時は例外発生としておく(仮仕様)

------------------------------------------------------------------------

次は球にグラデーションをつけてかっこ良くする。

* RGBのランダムな色を生成
    * 中心色は輝度0.5以上とする
    * 境界色は中心色から輝度を40%削減したもの
* グラデーションを生成
    * createRadialGradientを使う
    * 開始境界は球の外殻
    * 終点(グラデーション中心)は球の中心から1/4だけ左上の地点

(補足) 次はRGBのCSS表現`#rrggbb`を得るためのパターン。JavaScriptにはprintfのように先頭に0を埋める機能がないため、このようにsliceと組み合わせて生成する。

``` coffeescript
    innerCol = 0x003f6c   # (例)このような場合に先頭の00を確保するのが次コード
    innerRgb = innerCol.toString 16
    innerColor = '#000000'.slice(0, 7 - innerRgb.length) + innerRgb
```

------------------------------------------------------------------------

次は球を動かす。ただしまだ衝突はさせない。

* 球の初速はランダムに割り当てる
* 球同士の衝突判定はしない(オーバーラップしたら素通りする)
* 周囲の壁面は完全反射とする(これが一番簡単)
* 30 frame/sec でアニメーション

> ボールの数が25個だとCPU負荷がめちゃ高い(後で調整する)。

------------------------------------------------------------------------

次は球を衝突させる。

* 完全弾性衝突モデル(質量パラメータあり)
* 反射の数式は種本から頂戴した
    * 物理は得意なので自作可能
        * たぶんもっと厳密なのを作れる
        * しかし本気で作ると2-3日は掛かりそう
    * でもせっかく動くのがあるのだから利用する
        * おそらく2-3日の時間節約になる
        * 実はコードを読むとどうも厳密ではなさそう
        * しかし実際に動かしてみて特に不自然な点は見当たらない
        * 人間の感覚を騙すことには十分成功していると判断して採用する
    * ただしその後自分で大幅にreduceしたため原型は全くとどめていない
* 球の質量は半径に比例させる
    * 厳密に数学を適用すれば球なので3乗に比例させるべき
    * だが実際にやってみると当然小さな球が高速で飛び回ることになる
    * それっぽく見える程度でいいのでかえって単純比例の方が自然に見える

> ここでちょっと面白いことに気付いた。ChromeよりFirefoxの方がCPU負荷が少ない。普通なら完全に逆なのでこれはCanvas特有の現象だろう。

------------------------------------------------------------------------

次は重力を追加する。最初は設定は固定にする。

------------------------------------------------------------------------

次は(空気)抵抗を追加。次のシンプルな物理モデルを採用する。

* 抵抗力(加速度)は速度に比例して減衰する

しかしこれはまだ不完全。最後は地面を細かくバウンドする状態になり、いつまで経っても停止しない。

------------------------------------------------------------------------

最後は弾性係数を設定する。

> ここまでやれば物理モデリングと言っても差し支えないと思う。

* 衝突の対象は「球 vs 境界」と「球 vs 球」の2通りある(本来は別の値)
* しかしパラメータを増やしすぎても無用に複雑になるだけ
* 最低限のパラメータで豊かなバリエーションを表現できるのがベスト
    * よって一つに統一し
    * 2つの弾性係数の間に比例係数(定数)を設定する
    * 単に同じでもいい(最初はそうする)

これだけだとやはり最後は地面を細かくバウンドする。原因は重力で、常に一定の加速度を下向きに受けているため永久にバウンドが止まらない。

------------------------------------------------------------------------

